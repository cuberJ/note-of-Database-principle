# 并发控制

## 概念

1. 不可重复读：T1读取了数据后，T2紧接着修改了数据，T1后面验算发现数据变化（针对update）
2. 幻读：T1读取数据后，T2增加/删除了数据，T1事后发现数据数目变化了（针对delete/insert）
3. 脏读：T1修改了数据，并写回磁盘。随后T2读取了数据，但接着T1回滚了数据（把数据恢复到原先干净的地方），导致T2读到的是被T1修改过的“脏数据 ”



## 封锁

事务操作数据前，利用系统对数据加锁，其他事务不得修改该数据



### 基本锁

1. 排他锁（X锁）：其他事务不可读不可写，只允许加锁的事务读写。其他事务不得对数据加上任何锁
2. 共享锁（Share锁）：其他事务可读不可写，也可以加新的S锁 

根据锁的使用时间，使用环境建立不同的封锁协议



### 一级封锁协议

事务T在修改数据R前摇先加X锁，直到事务结束才释放

结束的方式包括commit和rollback两种皆可以



#### 作用

1. 可以防止修改不会丢失，保证事务T可恢复
2. 该协议在只读数据但不修改的情况下是不加锁的，所以不能保证可重复读以及不脏读



### 二级封锁协议

一级封锁的基础上，事务在读数据之前对其加S锁，读完解除S锁

1. 可以防止丢失修改和脏读

2. 但由于读完就要立刻解除，所以不保证可重复读

   > 二级封锁能防止脏读的原理：前一个事务回滚前是没有解除x锁的，所以下一个事务想读的时候是没法在x锁的基础上加s锁的



### 三级封锁协议

也是在<font color = red>一级封锁协议</font>的基础上，读取数据R之前必须加S锁，在事务结束后才可以释放

三级封锁可以避免一切冲突



### 活锁

在T1上锁数据后，多个其他事务同时申请加锁，系统没有设置队列方式，导致最先申请加锁的等待事务一直得不到批准，反而是后来的事务被批准加锁（本质就是饥饿）



对应的还有死锁：T1事务需要两个数据，锁了第一个之后发现第二个被T2锁了，同时T2也需要T1锁上的数据

#### 死锁的预防

1. 一次封锁：全部封锁所有的数据
2. 顺序封锁：对数据对象排序，事务只有按照次序去封锁数据（只有封锁了数据1，才允许封锁数据2）



### 死锁解除（常用）

1. 超时法：超时就认为死锁，回滚
2. 等待图：操作系统的有向图





# 串行化 

## 并发调度的可串行性

冲突可串行化是可串行化调度的充分条件，但不是必要条件

也就是说，存在一些情况，虽然不可冲突串行化，但也可以串行化调度